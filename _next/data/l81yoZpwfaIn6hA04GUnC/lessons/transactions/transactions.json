{"pageProps":{"post":{"attributes":{},"html":"<blockquote>\n<p>This lesson uses the recipeguru database again. Use <code>\\c recipeguru</code> to get back to the recipeguru database.</p>\n</blockquote>\n<p>I know we&#39;ve been dealing with recipes which has a high tolerance for errors, particularly around making multiple inserts and updates in one query. It&#39;s not life threatening if we accidentally publish a recipe without a photo or an ingredient that isn&#39;t attached to a recipe. But fathom for a moment usecases where it is critical where you need to do multiple things at once and they all need to happen or zero need to happen.</p>\n<p>A good example of this would be bank accounts. If Bob is transferring $10,000 from his account to Alice&#39;s account, we need to subtract $10,000 from Bob&#39;s account and add $10,000 to Bob&#39;s. <strong>Both</strong> of those need to happen or <strong>neither</strong> of those needs to happen. We need it to be one <em>atomic</em> transaction. Atomic in this case means indivisible, or rather it needs to happen as if it was one single query. If Bob <em>just</em> loses $10,000 and Alice doesn&#39;t gain it the bank is committing theft and if Alice <em>just</em> gains $10,000 and Bob doesn&#39;t lose it then the bank is losing money by paying Alice. If neither happens, they may be a bit mad that it&#39;s taking a long time to get the transfer done but no damage has been done and we can try again.</p>\n<p>This is what transactions are for with PostgreSQL. It allows you to say &quot;hey, PostgreSQL, do all of these things and if anything fails or doesn&#39;t work, then do none of it. Let&#39;s give it a shot with the recipes database.</p>\n<p>You can really drive home how this works by opening a second terminal to the database and run a</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">BEGIN</span>;\n\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> ingredients (title, type) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;whiskey&#x27;</span>, <span class=\"hljs-string\">&#x27;other&#x27;</span>);\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> ingredients (title, type) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;simple syrup&#x27;</span>, <span class=\"hljs-string\">&#x27;other&#x27;</span>);\n\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> recipes (title, body) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;old fashioned&#x27;</span>, <span class=\"hljs-string\">&#x27;mmmmmmm old fashioned&#x27;</span>);\n\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> recipe_ingredients\n  (recipe_id, ingredient_id)\n<span class=\"hljs-keyword\">VALUES</span>\n  (\n    (<span class=\"hljs-keyword\">SELECT</span> recipe_id <span class=\"hljs-keyword\">FROM</span> recipes <span class=\"hljs-keyword\">where</span> title<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;old fashioned&#x27;</span>),\n    (<span class=\"hljs-keyword\">SELECT</span> id <span class=\"hljs-keyword\">FROM</span> ingredients <span class=\"hljs-keyword\">where</span> title<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;whiskey&#x27;</span>)\n  ),\n  (\n    (<span class=\"hljs-keyword\">SELECT</span> recipe_id <span class=\"hljs-keyword\">FROM</span> recipes <span class=\"hljs-keyword\">where</span> title<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;old fashioned&#x27;</span>),\n    (<span class=\"hljs-keyword\">SELECT</span> id <span class=\"hljs-keyword\">FROM</span> ingredients <span class=\"hljs-keyword\">where</span> title<span class=\"hljs-operator\">=</span><span class=\"hljs-string\">&#x27;simple syrup&#x27;</span>)\n  );\n\n<span class=\"hljs-keyword\">COMMIT</span>;\n</code></pre>\n<ul>\n<li><code>BEGIN</code> is how you <em>start</em> a transaction. You&#39;re telling PostgreSQL &quot;I&#39;m giving a few queries now, don&#39;t run them until I say <code>COMMIT</code> and then run <em>all</em> of them.</li>\n<li>If you <code>BEGIN</code> and decide you don&#39;t want to <code>COMMIT</code> you can run <code>ROLLBACK;</code> and it will not run any queries.</li>\n<li>If you want really prove a point to yourself, run the <code>BEGIN</code> and the first three <code>INSERT INTO</code> commands but don&#39;t run the last INSERT or the COMMIT. Open a second psql instance and try to query for &quot;whiskey&quot; in the ingredients table. You won&#39;t find it because we didn&#39;t <code>COMMIT</code> yet.</li>\n<li><code>BEGIN</code> is short for <code>BEGIN WORK</code> or <code>BEGIN TRANSACTION</code>. Any of those work.</li>\n</ul>\n<p>I used subqueries to get the IDs. You can use variables if you use plpgsql language and use <code>RETURNING INTO</code> and a variable name. Let&#39;s just show you what that could look like.</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">BEGIN</span> WORK;\n\nDO $$\n<span class=\"hljs-keyword\">DECLARE</span> champagne <span class=\"hljs-type\">INTEGER</span>;\n<span class=\"hljs-keyword\">DECLARE</span> orange_juice <span class=\"hljs-type\">INTEGER</span>;\n<span class=\"hljs-keyword\">DECLARE</span> mimosa <span class=\"hljs-type\">INTEGER</span>;\n<span class=\"hljs-keyword\">BEGIN</span>\n\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> ingredients (title, type) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;champage&#x27;</span>, <span class=\"hljs-string\">&#x27;other&#x27;</span>) RETURNING id <span class=\"hljs-keyword\">INTO</span> champagne;\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> ingredients (title, type) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;orange_juice&#x27;</span>, <span class=\"hljs-string\">&#x27;other&#x27;</span>) RETURNING id <span class=\"hljs-keyword\">INTO</span> orange_juice;\n\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> recipes (title, body) <span class=\"hljs-keyword\">VALUES</span> (<span class=\"hljs-string\">&#x27;mimosa&#x27;</span>, <span class=\"hljs-string\">&#x27;brunch anyone?&#x27;</span>) RETURNING recipe_id <span class=\"hljs-keyword\">INTO</span> mimosa;\n\n<span class=\"hljs-keyword\">INSERT</span> <span class=\"hljs-keyword\">INTO</span> recipe_ingredients\n  (recipe_id, ingredient_id)\n<span class=\"hljs-keyword\">VALUES</span>\n  (mimosa, champagne),\n  (mimosa, orange_juice);\n\n<span class=\"hljs-keyword\">END</span> $$;\n\n<span class=\"hljs-keyword\">COMMIT</span> WORK;\n</code></pre>\n<ul>\n<li>This is just to show you a different way to do it without subqueries. We&#39;re using the plpgpsql feature of variables. This does not work in normal SQL, we have to use the programming language.</li>\n<li>Notice the <code>BEGIN WORK</code> and <code>COMMIT WORK</code> are <strong>outside</strong> of the function. Postgres can&#39;t do transactions inside of functions. Other SQL databases can, just not Postgres.</li>\n<li>There&#39;s a <code>BEGIN WORK</code> for the transaction and a <code>BEGIN</code> for the function. They&#39;re different and do different things. I used <code>BEGIN WORK;</code> to make it very clear to you but you can use <code>BEGIN;</code> and it&#39;d work just fine.</li>\n</ul>\n","slug":"transactions","title":"Transactions","section":"Transactions","icon":"envelopes-bulk","filePath":"/home/runner/work/complete-intro-to-sql/complete-intro-to-sql/lessons/12-transactions/A-transactions.md","nextSlug":"/lessons/window-functions/window-functions","prevSlug":"/lessons/subqueries/arrays"}},"__N_SSG":true}